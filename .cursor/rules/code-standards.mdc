---
description: General coding standards and best practices for the project
globs: ["**/*.ts", "**/*.tsx", "**/*.js", "**/*.jsx"]
alwaysApply: true
---

# Coding Standards

## ğŸŒ Language Requirements

### âœ… ALWAYS use English for code and documentation:

```tsx
// âœ… CORRECT - English code
export function calculateUserBalance(userId: string): number {
  // Calculate total balance
  const balance = getUserData(userId).balance;
  return balance;
}

// âœ… CORRECT - English comments
// This function validates the user input
// Returns true if valid, false otherwise

// âœ… CORRECT - English variable names
const userName = 'John';
const isValid = true;
const userBalance = 100;

// âŒ WRONG - Non-English code
export function Ğ²Ñ‹Ñ‡Ğ¸ÑĞ»Ğ¸Ñ‚ÑŒĞ‘Ğ°Ğ»Ğ°Ğ½Ñ(userId: string): number { ... }
const Ğ¸Ğ¼ÑĞŸĞ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»Ñ = 'John';

// âŒ WRONG - Mixed language comments
// Ğ­Ñ‚Ğ° Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ñ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ÑĞµÑ‚ Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ
```

### âœ… English applies to:
- âœ… Function names
- âœ… Variable names
- âœ… Type names
- âœ… Interface names
- âœ… Class names
- âœ… Comments
- âœ… Documentation (README.md)
- âœ… Commit messages
- âœ… Code comments
- âœ… Error messages (for developers)

### ğŸ“ Exception - User-facing text:
```tsx
// âŒ WRONG - hardcoded user text in English
<Text>Welcome to our app</Text>

// âœ… CORRECT - use i18n for user text
const { t } = useTranslation();
<Text>{t('app.welcome')}</Text>
```

**Code = English. User-facing text = i18n translations.**

---

## âœ… File Naming Convention:
- **Always use kebab-case**: `user-profile.tsx`, `send-token.ts`, `profile-api.ts`
- **Never use camelCase**: âŒ `userProfile.tsx`, âŒ `sendToken.ts`

## âœ… Component Structure:
- **Keep components under 200 lines**
- **Extract logic into custom hooks**
- **One responsibility per component**
- **One component per file** - NO EXCEPTIONS!

## ğŸš« NEVER write complex logic inside components!

### âŒ WRONG - Complex logic in component:

```tsx
function MyComponent() {
  // âŒ BAD - complex algorithm in component
  const calculateComplexValue = () => {
    let result = 0;
    for (let i = 0; i < data.length; i++) {
      const value = data[i].amount * rates[i];
      if (value > threshold) {
        result += value * 0.95;
      } else {
        result += value;
      }
    }
    return result;
  };

  // âŒ BAD - data transformation logic
  const processedData = rawData.map(item => ({
    ...item,
    formatted: formatCurrency(item.amount),
    isValid: validateItem(item),
    priority: calculatePriority(item),
  }));

  return <View>{/* render */}</View>;
}
```

### âœ… CORRECT - Extract to utilities:

```tsx
// features/my-feature/utils/calculations.ts
export function calculateComplexValue(data: Item[], rates: number[], threshold: number): number {
  let result = 0;
  for (let i = 0; i < data.length; i++) {
    const value = data[i].amount * rates[i];
    result += value > threshold ? value * 0.95 : value;
  }
  return result;
}

// features/my-feature/utils/data-processing.ts
export function processItems(items: RawItem[]): ProcessedItem[] {
  return items.map(item => ({
    ...item,
    formatted: formatCurrency(item.amount),
    isValid: validateItem(item),
    priority: calculatePriority(item),
  }));
}
```

```tsx
// Component is now clean
import { calculateComplexValue } from '../utils/calculations';
import { processItems } from '../utils/data-processing';

function MyComponent() {
  const result = calculateComplexValue(data, rates, threshold);
  const processed = processItems(rawData);
  
  return <View>{/* render */}</View>;
}
```

### âœ… CORRECT - Extract to custom hooks:

```tsx
// features/my-feature/hooks/use-processed-data.ts
export function useProcessedData(rawData: RawItem[]) {
  return useMemo(() => {
    return rawData.map(item => ({
      ...item,
      formatted: formatCurrency(item.amount),
      isValid: validateItem(item),
      priority: calculatePriority(item),
    }));
  }, [rawData]);
}
```

```tsx
// Component uses hook
import { useProcessedData } from '../hooks/use-processed-data';

function MyComponent() {
  const processedData = useProcessedData(rawData);
  return <View>{/* render */}</View>;
}
```

## ğŸ§© Component Decomposition - Break Complex Render into Smaller Components

### âŒ WRONG - Complex render in single component:

```tsx
function MyScreen() {
  return (
    <View>
      {/* âŒ BAD - too much JSX in one component */}
      <View className="p-4">
        <View className="flex-row items-center mb-4">
          <Image source={avatar} />
          <View>
            <Text variant="heading">{user.name}</Text>
            <Text variant="caption1">{user.email}</Text>
          </View>
        </View>
        
        <View className="mb-6">
          {stats.map(stat => (
            <View key={stat.id} className="flex-row justify-between p-2">
              <Text>{stat.label}</Text>
              <Text variant="heading">{stat.value}</Text>
            </View>
          ))}
        </View>
        
        <View>
          {transactions.map(tx => (
            <View key={tx.id} className="p-4 border-b">
              <Text>{tx.title}</Text>
              <Text variant="caption1">{tx.date}</Text>
              <Text>{tx.amount}</Text>
            </View>
          ))}
        </View>
      </View>
    </View>
  );
}
```

### âœ… CORRECT - Decompose into smaller components:

```tsx
// features/my-feature/components/user-header.tsx
export function UserHeader({ user }: { user: User }) {
  return (
    <View className="flex-row items-center mb-4">
      <Image source={user.avatar} />
      <View>
        <Text variant="heading">{user.name}</Text>
        <Text variant="caption1">{user.email}</Text>
      </View>
    </View>
  );
}

// features/my-feature/components/stats-list.tsx
export function StatsList({ stats }: { stats: Stat[] }) {
  return (
    <View className="mb-6">
      {stats.map(stat => (
        <StatItem key={stat.id} stat={stat} />
      ))}
    </View>
  );
}

// features/my-feature/components/stat-item.tsx
export function StatItem({ stat }: { stat: Stat }) {
  return (
    <View className="flex-row justify-between p-2">
      <Text>{stat.label}</Text>
      <Text variant="heading">{stat.value}</Text>
    </View>
  );
}

// features/my-feature/components/transaction-list.tsx
export function TransactionList({ transactions }: { transactions: Transaction[] }) {
  return (
    <View>
      {transactions.map(tx => (
        <TransactionItem key={tx.id} transaction={tx} />
      ))}
    </View>
  );
}

// features/my-feature/components/transaction-item.tsx
export function TransactionItem({ transaction }: { transaction: Transaction }) {
  return (
    <View className="p-4 border-b">
      <Text>{transaction.title}</Text>
      <Text variant="caption1">{transaction.date}</Text>
      <Text>{transaction.amount}</Text>
    </View>
  );
}

// features/my-feature/components/my-screen.tsx - NOW CLEAN!
import { UserHeader } from './user-header';
import { StatsList } from './stats-list';
import { TransactionList } from './transaction-list';

export function MyScreen() {
  return (
    <View className="p-4">
      <UserHeader user={user} />
      <StatsList stats={stats} />
      <TransactionList transactions={transactions} />
    </View>
  );
}
```

## ğŸ“‹ Component File Rules

### âœ… ONE component per file:

```tsx
// âœ… CORRECT
// user-header.tsx
export function UserHeader() { ... }

// user-avatar.tsx  
export function UserAvatar() { ... }

// user-info.tsx
export function UserInfo() { ... }
```

### âŒ WRONG - Multiple components in one file:

```tsx
// âŒ WRONG - multiple components
// user-components.tsx
export function UserHeader() { ... }
export function UserAvatar() { ... }
export function UserInfo() { ... }
```

**Exception:** Helper types or small internal utilities can be in same file.

## ğŸ¯ When to Decompose Components

### Decompose when:
- âœ… Component > 100 lines of JSX
- âœ… Repeated render patterns
- âœ… Complex nested structures (> 3 levels)
- âœ… Map rendering with complex items
- âœ… Conditional render blocks with complex JSX
- âœ… Reusable UI patterns

### Signs you need decomposition:
- ğŸš¨ Too many nested Views (> 4 levels)
- ğŸš¨ Long map() with complex JSX
- ğŸš¨ Repeated JSX structures
- ğŸš¨ Hard to understand what component does
- ğŸš¨ Component over 150 lines

## ğŸ¯ When to Extract Logic

### Extract to UTILITY file when:
- âœ… Pure calculation/transformation functions
- âœ… Validation logic
- âœ… Formatting functions
- âœ… Complex algorithms
- âœ… Business logic
- âœ… Reusable across components

### Extract to HOOK when:
- âœ… Uses React hooks (useState, useEffect, etc.)
- âœ… Component lifecycle logic
- âœ… Side effects
- âœ… API data fetching/mutations
- âœ… Form state management
- âœ… Reusable stateful logic

### Keep in COMPONENT when:
- âœ… Simple event handlers (1-3 lines)
- âœ… Simple state (useState, local UI state)
- âœ… JSX rendering logic
- âœ… Simple prop transformations

## ğŸ“‚ File Organization

```
features/my-feature/
â”œâ”€â”€ components/
â”‚   â”œâ”€â”€ my-screen.tsx           # âœ… Main screen, < 200 lines
â”‚   â”œâ”€â”€ user-header.tsx         # âœ… Decomposed component
â”‚   â”œâ”€â”€ stats-list.tsx          # âœ… Decomposed component
â”‚   â”œâ”€â”€ stat-item.tsx           # âœ… Small item component
â”‚   â””â”€â”€ transaction-list.tsx    # âœ… Decomposed component
â”œâ”€â”€ hooks/
â”‚   â”œâ”€â”€ use-my-data.ts         # âœ… React Query hook
â”‚   â””â”€â”€ use-form-state.ts      # âœ… Form logic hook
â”œâ”€â”€ utils/
â”‚   â”œâ”€â”€ calculations.ts         # âœ… Pure functions
â”‚   â”œâ”€â”€ validators.ts           # âœ… Validation logic
â”‚   â””â”€â”€ formatters.ts           # âœ… Formatting functions
â””â”€â”€ types/
    â””â”€â”€ my-types.ts
```

## âœ… Component Size Limits:
- **React Native components**: max 200 lines
- **Hooks**: max 150 lines  
- **Utilities**: max 100 lines
- **If larger**: decompose into smaller pieces

## âœ… Import Organization:
```tsx
// 1. External libraries
import React from 'react';
import { View } from 'react-native';

// 2. Internal components
import { Button } from '~/components/button';

// 3. Hooks and utilities
import { useMyData } from '../hooks/use-my-data';
import { calculateValue } from '../utils/calculations';

// 4. Types
import type { IUser } from './types';
```

## âœ… Error Handling:
```tsx
// Always handle potential errors
try {
  await apiCall();
} catch (error) {
  console.error('Specific operation failed:', error);
  // Show user-friendly message
}
```

## âœ… Type Safety:
```tsx
// Always validate data before using
if (!data || typeof data !== 'string') {
  throw new Error('Invalid data type');
}
```

## ğŸš« NEVER DO:
- âŒ Write complex algorithms in components
- âŒ Put business logic in components
- âŒ Write data transformations in components
- âŒ Create multiple components in one file
- âŒ Keep complex render in single component (decompose!)
- âŒ Render numbers directly in JSX
- âŒ Use camelCase file names  
- âŒ Create files over 300 lines
- âŒ Use any without explicit typing
- âŒ Ignore error handling
- âŒ Duplicate code - create utility functions

## âœ… ALWAYS DO:
- âœ… Extract complex logic to utils/ folder
- âœ… Extract stateful logic to hooks/ folder
- âœ… Keep components focused on rendering
- âœ… Create utility functions for calculations
- âœ… Use custom hooks for React-specific logic
- âœ… Decompose complex JSX into smaller components
- âœ… One component per file (descriptive name)
- âœ… Name files descriptively (what they do)
- âœ… Keep files small and focused

## ğŸ’¡ REMEMBER:
Your employer will be very unhappy if code doesn't work. Always prioritize:
1. **Reliability** over performance
2. **Type safety** over convenience  
3. **Error handling** over clean code
4. **Testing** edge cases thoroughly
5. **Never duplicate code** - when you see duplication, create utility function and share it
6. **Components are for rendering** - logic goes in hooks/utils
7. **Decompose complex render** - create smaller helper components in separate files
